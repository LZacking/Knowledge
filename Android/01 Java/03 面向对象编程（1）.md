# 3 面向对象编程（1）

3.1 类和对象的区别和联系

3.2 属性/成员变量/字段

3.3 成员方法

3.4 成员方法传参机制

3.5 方法递归调用

3.6 方法重载(OverLoad)

3.7 可变参数

3.8 作用域

3.9 构造方法/构造器

3.10 this关键字





## 3.1 类和对象的区别和联系

- 类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型
- 对象是具体的，实际的，代表一个具体事物, 即 是实例
- 类是对象的模板，对象是类的一个个体，对应一个实例



## 3.2 属性/成员变量/字段

- 从概念或叫法上看： 成员变量 = 属性 = field(字段) （即 成员变量是用来表示属性的，接下来的文档中，统一叫 属性)
- 属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)



**注意事项和细节说明** 

（1）属性的定义语法同变量，示例：访问修饰符 属性类型 属性名; 

访问修饰符： 控制属性的访问范围 

有四种访问修饰符 public, proctected, 默认, private ,后面我会详细介绍 

（2）属性的定义类型可以为任意类型，包含基本类型或引用类型 

（3）属性如果不赋值，有默认值，规则和数组一致。具体说: 

int 0

short 0

byte 0

long 0

float 0.0

double 0.0

char \u0000

boolean false

String null



**如何创建对象** 

（1）先声明再创建 

Cat cat ; //声明对象 cat 

cat = new Cat(); //创建 

（2）直接创建 

Cat cat = new Cat();                             


**如何访问属性** 

对象名.属性名; 

cat.age



## 3.3 成员方法

在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一 

些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用**成员方法**才能完成



**成员方法的好处** 

- 提高代码的复用性 
- 可以将实现的细节封装起来，然后供其他用户来调用即可 



**成员方法的定义** 

```java
访问修饰符 返回数据类型 方法名（形参列表..） {//方法体 

语句； 

return 返回值; 

}
```

- 形参列表：表示成员方法输入
- 返回数据类型：表示成员方法输出, void 表示没有返回值 
- 方法主体：表示为了实现某一功能代码块 
- return 语句不是必须的



**注意事项和使用细节**

访问修饰符 (作用是控制 方法使用的范围) 

- 如果不写默认访问，[有四种: public, protected, 默认, private]



返回数据类型 

- 一个方法最多有一个返回值 [思考，如何返回多个结果 返回数组 ] 
- 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) 
- 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的 值类型一致或兼容 
- 如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return 



方法名 

遵循驼峰命名法，最好见名知义，表达出该功能的意思即可



## 3.4 成员方法传参机制

**基本数据类型传参**

基本数据类型传参，传递的是值（值拷贝），形参的任何改变不影响实参

```java

public class MethodParameter01 { 

	// 编写一个main方法
	public static void main(String[] args) {

		int a = 10;
		int b = 20;
		// 创建AA对象 名字 obj
		AA obj = new AA();
		obj.swap(a, b); // 调用swap

		System.out.println("main方法 a=" + a + " b=" + b);// a=10 b=20
	}
}

class AA {
	public void swap(int a,int b){
		System.out.println("\na和b交换前的值\na=" + a + "\tb=" + b);// a=10 b=20
		// 完成了 a 和 b的交换
		int tmp = a;
		a = b;
		b = tmp;
		System.out.println("\na和b交换后的值\na=" + a + "\tb=" + b);// a=20 b=10
	}
}
```



**引用数据类型的传参机制**

引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参

```java

public class MethodParameter02 { 
	//编写一个main方法
	public static void main(String[] args) {
		//测试
		B b = new B();
		int[] arr = {1, 2, 3};
		b.test100(arr);//调用方法
		System.out.println(" main的 arr数组 ");
		//遍历数组
		for(int i = 0; i < arr.length; i++) {
		 	System.out.print(arr[i] + "\t");
		}
	}
}

class B {
	//B类中编写一个方法test100，
	//可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化
	public void test100(int[] arr) {
		arr[0] = 200;//修改元素
		//遍历数组
		System.out.println(" test100的 arr数组 ");
		for(int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + "\t");
		}
		System.out.println();
	}
}
```



## 3.5 方法递归调用

简单的说: **递归就是方法自己调用自己**,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变得简洁

- 打印问题 
- 阶乘问题

```java
public class Recursion01 { 

	//编写一个main方法
	public static void main(String[] args) {
		T t1 = new T();
		t1.test(4);//输出什么？ n=2 n=3 n=4
		int res = t1.factorial(5); 
		System.out.println("5的阶乘 res =" + res);
	}
}

class T {
	//分析
	public  void test(int n) {
		if (n > 2) {
			test(n - 1);
		} 
		System.out.println("n=" + n);
	}

	//factorial 阶乘
	public  int factorial(int n) {
		if (n == 1) {
			return 1;
		} else {
			return factorial(n - 1) * n;
		}
	}

}
```



## 3.6 方法重载(OverLoad)

java 中允许同一个类中，多个同名方法的存在，但要求形参列表不一致（两同一不同）

形参列表：形参类型、个数、顺序，至少一个不同

```java
public class OverLoad01 { 

	//编写一个main方法
	public static void main(String[] args) {
        
		MyCalculator mc = new MyCalculator();
		System.out.println(mc.calculate(1, 2));
		System.out.println(mc.calculate(1.1, 2));
		System.out.println(mc.calculate(1, 2.1));
	}
}

class MyCalculator  {

	//下面的四个 calculate方法构成了重载
	//两个整数的和
	public int calculate(int n1, int n2)  {
		System.out.println("calculate(int n1, int n2) 被调用");
		return n1 + n2;
	}

	//一个整数，一个double的和
	public double calculate(int n1, double n2) {
		return n1 + n2;
	}
    
	//一个double ,一个Int和 
	public double calculate(double n1, int n2) {
		System.out.println("calculate(double n1, int n2) 被调用..");
		return n1 + n2;
	}
    
	//三个int的和
	public int calculate(int n1, int n2,int n3) {
		return n1 + n2 + n2;
	}

}
```



## 3.7 可变参数

java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法，就可以通过可变参数实现

**注意事项**

- 可变参数的实参可以为0个或者多个
- 可变参数的实参可以是数组
- 可变参数的本质就是数组
- 可变参数可以和普通类型的参数一起放在形参列表中，但必须保证可变参数在最后
- 一个形参列表中只能有一个可变参数

```java
访问修饰符 返回类型 方法名(数据类型... 形参名) { 

}
```

```java
public class VarParameter { 

	//编写一个main方法
	public static void main(String[] args) {

		HspMethod m = new HspMethod();
		System.out.println(m.sum(1, 5, 100)); //106
		System.out.println(m.sum(1,19)); //20
	}
}

class HspMethod {
	//可以计算 2个数的和，3个数的和 ， 4. 5， 。。
	//可以使用方法重载
	// public int sum(int n1, int n2) {//2个数的和
	// 	return n1 + n2;
	// }
	// public int sum(int n1, int n2, int n3) {//3个数的和
	// 	return n1 + n2 + n3;
	// }
	// public int sum(int n1, int n2, int n3, int n4) {//4个数的和
	// 	return n1 + n2 + n3 + n4;
	// }
	//.....
	//上面的三个方法名称相同，功能相同, 参数个数不同-> 使用可变参数优化
	//1. int... 表示接受的是可变参数，类型是int ,即可以接收多个int(0-多) 
	//2. 使用可变参数时，可以当做数组来使用 即 nums 可以当做数组
	//3. 遍历 nums 求和即可
	public int sum(int... nums) {
		//System.out.println("接收的参数个数=" + nums.length);
		int res = 0;
		for(int i = 0; i < nums.length; i++) {
			res += nums[i];
		}
		return res;
	}
}
```



## 3.8 作用域

面向对象中，变量作用域是非常重要知识点

在java编程中，主要的变量就是属性（成员变量）和局部变量，我们说的局部变量一般是指在成员方法中定义的变量

java中作用域的分类：

全局变量：也就是属性，作用域为整个类体 Cat类：cry eat 等方法使用属性
局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中

全局变量（属性）可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值



**注意事项和细节使用**

（1）属性和局部变量可以重名，访问时遵循就近原则

（2）在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名

（3）属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中

（4）作用域范围不同
全局变量/属性：可以被本类使用，或其他类使用（通过对象调用）局部变量：只能在本类中对应的方法中使用

（5）修饰符不同
全局变量/属性可以加修饰符
局部变量不可以加修饰符

```java

public class VarScopeDetail { 

	//编写一个main方法
	public static void main(String[] args) {
		Person p1 = new Person();
		/*
		属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。
		局部变量，生命周期较短，伴随着它的代码块的执行而创建，
		伴随着代码块的结束而销毁。即在一次方法调用过程中
		 */
		//p1.say();//当执行say方法时，say方法的局部变量比如name,会创建，当say执行完毕后
		//name局部变量就销毁,但是属性(全局变量)仍然可以使用
		//
		T t1 = new T();
		t1.test(); //第1种跨类访问对象属性的方式

		t1.test2(p1);//第2种跨类访问对象属性的方式

	}
}

class T {

	//全局变量/属性：可以被本类使用，或其他类使用（通过对象调用)
	public void test() {
		Person p1 = new Person();
		System.out.println(p1.name);//jack
	}

	public void test2(Person p) {
		System.out.println(p.name);//jack
	}
}

class Person {
	//细节: 属性可以加修饰符(public protected private..)
	//      局部变量不能加修饰符
	public int age = 20;

	String name = "jack";

	public void say() {
		//细节 属性和局部变量可以重名，访问时遵循就近原则
		String name = "king";
		System.out.println("say() name=" + name);
	}

	public void hi() {
		String address = "北京";
		//String address = "上海";//错误,重复定义变量
		String name = "lzacking";//可以
	}
}
```



## 3.9 构造方法/构造器

来看一个需求：前面在创建人类的对象时，是先把一个对象创建好后，再给他的年龄和姓名属性赋值，如 

果现在我要求，在创建人类的对象时，就直接指定这个对象的年龄和姓名，该怎么做? 这时就可以使用构造器 



**基本语法** 

```java
[修饰符] 方法名(形参列表) { 

方法体; 

} 
```

1) 构造器的修饰符可以默认， 也可以是 public protected private 

2) 构造器没有返回值 

3) 方法名和类名字必须一样 

4) 参数列表和成员方法一样的规则 

5) 构造器的调用, 由系统完成 



构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。它有几个特点： 

1) 方法名和类名相同 

2) 没有返回值 

3) 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。

```java
public class Constructor { 

	//编写一个main方法
	public static void main(String[] args) {
		//当我们new 一个对象时，直接通过构造器指定名字和年龄
		Person p1 = new Person("smith", 80);
		System.out.println("p1的信息如下");
		System.out.println("p1对象name=" + p1.name);//smith
		System.out.println("p1对象age=" + p1.age);//80
	}
}

//在创建人类的对象时，就直接指定这个对象的年龄和姓名
class Person {
	String name;
	int age;
	//构造器
	//1. 构造器没有返回值, 也不能写void
	//2. 构造器的名称和类Person一样
	//3. (String pName, int pAge) 是构造器形参列表，规则和成员方法一样
	public  Person(String pName, int pAge) {
		System.out.println("构造器被调用~~ 完成对象的属性初始化");
		name = pName;
		age = pAge;
	}
}
```



**注意事项和使用细节** 

（1）一个类可以定义多个不同的构造器，即构造器重载比如：我们可以再给Person类定义一个构造器，用来创建对象的时候，只指定人名，不需要指定年龄

（2）构造器名和类名要相同

（3）构造器没有返回值

（4）构造器是完成对象的初始化，并不是创建对象

（5）在创建对象时，系统自动的调用该类的构造方法

（6）如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器）

（7）一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下



## 3.10 this关键字

this代表当前对象

```java

public class TestPerson { 

	//编写一个main方法
	public static void main(String[] args) {

		Person p1 = new Person("mary", 20);
		Person p2 = new Person("mary", 20);

		System.out.println("p1和p2比较的结果=" + p1.compareTo(p2));
	}
}

/*
定义Person类，里面有name、age属性，并提供compareTo比较方法，
用于判断是否和另一个人相等，提供测试类TestPerson用于测试, 
名字和年龄完全一样，就返回true, 否则返回false

 */
class Person {
	String name;
	int age;
	//构造器
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
	//compareTo比较方法
	public boolean compareTo(Person p) {
		//名字和年龄完全一样
		// if(this.name.equals(p.name) && this.age == p.age) {
		// 	return true;
		// } else {
		// 	return false;
		// }
		return this.name.equals(p.name) && this.age == p.age;
	}
}
```



**this 的注意事项和使用细节** 

this 关键字可以用来访问本类的属性、方法、构造器 

this 用于区分当前类的属性和局部变量 

访问成员方法的语法：this.方法名(参数列表)

访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句) 

 this 不能在类定义的外部使用，只能在类定义的方法中使用
